/*
 *                                Copyright (C) 2017 by Rafael Santiago
 *
 * This is a free software. You can redistribute it and/or modify under
 * the terms of the GNU General Public License version 2.
 *
 */
.section .data
cells:
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

alive_fmt:
    .asciz "\033[41m \033[m\r"

dead_fmt:
    .asciz "\033[40m \033[m\r"

gotoxy_fmt:
    .asciz "\033[%d;%dH"

clrscr_fmt:
    .asciz "\033[2J"

newline_fmt:
    .asciz "\n"

alive_cell_nr:
    .int 0

usleep_time:
    .int 200000

cell_row_min:
    .int 0

cell_col_min:
    .int 0

cell_row_max:
    .int 19

cell_col_max:
    .int 19

cell_bytes_per_row:
    .int 40  /* INFO(Rafael): This variable must store the real maximum of columns. */

sigint_watchdog_fmt:
    .asciz "Quit.\n"

option_cell_color:
    .asciz "--cell-color="

option_interactive:
    .asciz "--interactive"

default_cell_color:
    .asciz "red"

test_fmt:
    .asciz "DATA: %s\n"

option_fmt:
    .asciz "Option: %s\n"

option_status:
    .asciz "Status: %d\n"

.section .text

.globl _start

_start:

    /* INFO(Rafael): No problem on using immediate values for POSIX signals here,
                     they are standard, any decent UNIX will follow them...
                     It would be AWESOME if we could or'ing all this shit up, hu?... :-\*/

    pushl $sigint_watchdog
    pushl $2
    call signal
    addl $8, %esp

    pushl $sigint_watchdog
    pushl $3
    call signal
    addl $8, %esp

    pushl $sigint_watchdog
    pushl $15
    call signal
    addl $8, %esp

    call clrscr

    call life

#    pushl $default_cell_color
#    pushl $option_cell_color
#    call get_option
#    addl $8, %esp

#    pushl %eax
#    pushl $option_fmt
#    call printf
#    addl $8, %esp

#    pushl $0
#    pushl $option_interactive
#    call get_bool_option
#    addl $8, %esp

#    pushl %eax
#    pushl $option_status
#    call printf
#    addl $8, %esp

#    pushl $0
#    call exit

.type sigint_watchdog, @function
sigint_watchdog: /* sigint_watchdog(int signo) */
    /* INFO(Rafael): Fuck the callstack, the sky is falling here :D */

    /* TODO(Rafael): Bad, because is not a good idea to call printf from this
                     kind of function. It should be improved on. Maybe a
                     silly dummy flag holding the main loop. */

    call clrscr

    pushl $sigint_watchdog_fmt
    call printf
    addl $4, %esp

    pushl $0
    call exit
ret

.type get_option, @function
get_option: /* get_option(option, default) */

    /* INFO(Rafael): Get the option loading it into EAX, if it does not exist load the default value from the stack  (C Style)*/

    pushl %ebp
    movl %esp, %ebp

    cmp $1, 16(%ebp)
    je get_option_default

    movl 8(%ebp), %edi
    pushl %edi
    movl $0xffff, %ecx
    movb $0, %al
    cld
    repne scasb
    popl %edi

    subw $0xfffe, %cx
    neg %cx

    movl %ebp, %edx
    addl $24, %edx

    get_option_parse_args:
        pushl %edi
        pushl %ecx

        movl (%edx), %esi

        repe cmpsb

        popl %ecx
        popl %edi

        jne get_option_parse_args_go_next

        movl %esi, %eax

        jmp get_option_epilogue

        get_option_parse_args_go_next:
            addl $4, %edx

        cmp $0, (%edx)
    jne get_option_parse_args

    get_option_default:
        movl 12(%ebp), %eax

    get_option_epilogue:
        movl %ebp, %esp
        popl %ebp
ret

.type get_bool_option, @function
get_bool_option: /* get_bool_option(option, default_state) */

    /* INFO(Rafael): Get the boolean option loading its state into EAX, if it does not exist load the default state value from the stack  (C Style)*/

    /* TODO(Rafael): This is quite equals to the get_option(), try to implement the behavior of the two into
                                     a new one without fucking the caller's brain */

    pushl %ebp
    movl %esp, %ebp

    cmp $1, 16(%ebp)
    je get_bool_option_default

    movl 8(%ebp), %edi
    pushl %edi
    movl $0xffff, %ecx
    movb $0, %al
    cld
    repne scasb
    popl %edi

    subw $0xfffe, %cx
    neg %cx

    movl %ebp, %edx
    addl $24, %edx

    get_bool_option_parse_args:
        pushl %edi
        pushl %ecx

        movl (%edx), %esi

        repe cmpsb

        popl %ecx
        popl %edi

        jne get_bool_option_parse_args_go_next

        movl $1, %eax

        jmp get_bool_option_epilogue

        get_bool_option_parse_args_go_next:
            addl $4, %edx

        cmp $0, (%edx)
    jne get_bool_option_parse_args

    get_bool_option_default:
        movl 12(%ebp), %eax

    get_bool_option_epilogue:
        movl %ebp, %esp
        popl %ebp
ret

.type life, @function
life: /* life() */
    pushl %ebp
    movl %esp, %ebp

    xorl %eax, %eax
    xorl %ebx, %ebx

    gameloop:
        call genprint

        pushl usleep_time
        call usleep
        addl $4, %esp

        call apply_rules
    jmp gameloop

    movl %ebp, %esp
    popl %ebp
ret

.type clrscr, @function
clrscr: /* clrscr() */
    pushl %ebp
    movl %esp, %ebp

    pushl $clrscr_fmt
    call printf
    addl $4, %esp

    movl $1, %eax
    movl $2, %ebx

    call gotoxy

    movl %ebp, %esp
    popl %ebp
ret

.type gotoxy, @function
gotoxy: /* gotoxy(EAX, EBX) */
    pushl %ebp
    movl %esp, %ebp

    pushl %eax
    pushl %ebx
    pushl $gotoxy_fmt
    call printf
    addl $12, %esp

    movl %ebp, %esp
    popl %ebp
ret

.type genprint, @function
genprint: /* genprint() */
    /*
     * INFO(Rafael): Well, it prints one generation.
     *
     * During its execution...
     *
     * EAX and EBX store the x, y coordinates used on gotoxy() calls
     * ECX holds the base offset of "cells" (a.k.a row index -> cells[y][]...)
     * EDI holds the col index of "cells" cells[][x]...
     * EDX holds the current byte stored in cell[][x]...
     *
     */
    pushl %ebp
    movl %esp, %ebp

    pushl %ecx

    xorl %ecx, %ecx
    movl $2, %ebx

    rloop:
        xorl %edi, %edi
        movl $1, %eax

        cloop:
            pushl %eax

            movl %ecx, %eax
            imul cell_bytes_per_row, %eax

            movl cells(%eax, %edi, 1), %edx

            popl %eax

            pushl %eax
            pushl %ebx
            pushl %ecx
            pushl %edx
            pushl %edi

            cmp $1, %dl
            je push_alive

            pushl $dead_fmt
            jmp cellprint

            push_alive:
                pushl $alive_fmt

            cellprint:
                call gotoxy

            call printf
            addl $4, %esp

            popl %edi
            popl %edx
            popl %ecx
            popl %ebx
            popl %eax

            inc %edi
            inc %eax
            cmp cell_col_max, %edi
        jle cloop

        pushl %eax
        pushl %ebx
        pushl %ecx
        pushl %edx
        pushl %edi

        pushl $newline_fmt
        call printf
        addl $4, %esp

        popl %edi
        popl %edx
        popl %ecx
        popl %ebx
        popl %eax

        inc %ecx
        inc %ebx

        cmp cell_row_max, %ecx
    jle rloop

    popl %ecx

    movl %ebp, %esp
    popl %ebp
ret

.type apply_rules, @function
apply_rules: /* apply_rules(EAX, EBX) */
    /*
     * INFO(Rafael): If life sucks to you, I think that you should start from here ;)
     */
    pushl %ebp
    movl %esp, %ebp
    pushl %eax
    pushl %ebx
    pushl %edx

    /* INFO(Rafael): Basically it traverses the cells inspecting the neighbours of each one and then applies
                     the game rules.

                     I think that use a kind of "temp_cells", "aux_cells" only to store the next generation data
                     is quite useless and a waste of memory, due to it I have chosen to store the next generation
                     data in the most significant nibble from the "cells", it still sucks but less.

                     So, the first (row;col) iteration generates a kind of "alternative universe"... the second one
                     takes Alice (without Bob and Eva but with us) there by right shifting our current "brana" 
                     (Ha-ha..) 4 bits. ;) */

    xorl %eax, %eax

    apply_rules_rloop.0:

        xorl %ebx, %ebx

        apply_rules_cloop.0:

            call inspect_neighbourhood

            pushl %eax
            imul cell_bytes_per_row, %eax

            pushl %ecx
            movl cells(%eax, %ebx, 1), %ecx

            cmp $1, %cl
            jne deadcell_rules

            livecell_rules:

                cmp $2, alive_cell_nr

                jl underpopulation

                je next_generation

                cmp $3, alive_cell_nr

                je next_generation

                jg overpopulation

                /* RULE(1): Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. */
                underpopulation:
                    /* INFO(Rafael): The next generation nibble is already zero, thus just skipping to increment stuff. */
                    jmp apply_rules_cloop_inc

                /* RULE(2): Any live cell with two or three live neighbours lives on to the next generation. */
                next_generation:
                    xorb $0x10, %cl
                    jmp apply_rules_cloop_inc

                /* RULE(3): Any live cell with more than three live neighbours dies, as if by overpopulation. */
                overpopulation:
                    /* INFO(Rafael): The next generation nibble is already '0', thus just skip to increment stuff. */
                    jmp apply_rules_cloop_inc

            deadcell_rules:
                cmp $3, alive_cell_nr
                jne apply_rules_cloop_inc

                /* RULE(4): Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction. */
                reproduction:
                    xorb $0x10, %cl

            apply_rules_cloop_inc:
                /* INFO(Rafael): Nice, now we got the present and future of this cell at the same byte. */
                movb %cl, cells(%eax, %ebx, 1)
                inc %ebx

            popl %ecx
            popl %eax

            cmp cell_col_max, %ebx
        jle apply_rules_cloop.0

        inc %eax
        cmp cell_row_max, %eax
    jle apply_rules_rloop.0

    xorl %eax, %eax
    xorl %edx, %edx

    /* INFO(Rafael): The lair of the rabbit... */

    apply_rules_rloop.1:
        xorl %ebx, %ebx
        pushl %eax
        imul cell_bytes_per_row, %eax
        apply_rules_cloop.1:
            shrb $4, cells(%eax, %ebx, 1) /* now step out kids, it will shift space and time... */
            inc %ebx
            cmp cell_col_max, %ebx
        jle apply_rules_cloop.1
        popl %eax
        inc %eax
        cmp cell_row_max, %eax
    jle apply_rules_rloop.1

    popl %edx
    popl %ebx
    popl %eax
    movl %ebp, %esp
    popl %ebp
ret

.type inspect_neighbourhood, @function
inspect_neighbourhood: /* inspect_neighbourhood(EAX, EBX) */
    /*
     * INFO(Rafael): Given a "high level" coordinate [ E.g.: cells(1;1) ]...
     *
     * ...this function will inspect the neighbours of the related cell, getting the amount of
     * alive cells. When calling this function, the EAX register must hold the "y" and the EBX the "x".
     *
     *                                           T T T
     * This game defines your neighbourhood as:  T U T
     *                                           T T T
     *
     * Maybe this function could be improved to evalute only the enough to take some decision instead
     * of visiting and counting every neighbours. However, by now it is okay.
     */

    pushl %ebp
    movl %esp, %ebp
    pushl %eax

    movl %ebx, %edi

    movl $0, alive_cell_nr

    /* INFO(Rafael): Inspecting the state of cells[r+1][c]. */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1c_end

    inc %eax
    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r1c_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c]. */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1c_end

    dec %eax

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r_1c_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c+1]. */

    pushl %eax
    pushl %edi

    cmp cell_col_max, %edi
    je rule_r_c1_end

    inc %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c-1]. */

    pushl %eax
    pushl %edi

    cmp cell_col_min, %edi
    je rule_r_c_1_end

    dec %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c-1]. */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1_c_1_end

    cmp cell_col_min, %edi
    je rule_r_1_c_1_end

    dec %eax
    dec %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r_1_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c+1]. */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1_c1_end

    cmp cell_col_max, %edi
    je rule_r_1_c1_end

    dec %eax
    inc %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r_1_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c-1]. */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1_c_1_end

    cmp cell_col_min, %edi
    je rule_r1_c_1_end

    inc %eax
    dec %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r1_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c+1]. */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1_c1_end

    cmp cell_col_max, %edi
    je rule_r1_c1_end

    inc %eax
    inc %edi

    imul cell_bytes_per_row, %eax

    movl cells(%eax, %edi, 1), %eax
    andb $1, %al

    cmp $1, %al
    jne rule_r1_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1_c1_end:
        popl %edi
        popl %eax

    popl %eax
    movl %ebp, %esp
    popl %ebp
ret
