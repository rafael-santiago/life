/*
 *                                Copyright (C) 2017 by Rafael Santiago
 *
 * This is a free software. You can redistribute it and/or modify under
 * the terms of the GNU General Public License version 2.
 *
 */
.section .data
cells:
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00

alive_fmt:
    .asciz "\033[41m \033[m\r"

dead_fmt:
    .asciz "\033[40m \033[m\r"

gotoxy_fmt:
    .asciz "\033[%d;%dH"

clrscr_fmt:
    .asciz "\033[2J"

newline_fmt:
    .asciz "\n"

alive_cell_nr:
    .int 0

usleep_time:
    .int 200000

cell_row_min:
    .int 0

cell_row_max:
    .int 19

cell_col_min:
    .int 0

cell_col_max:
    .int 19

.section .text

.globl _start

_start:

    call clrscr

    call life

    pushl $0
    call exit

.type life, @function
life:
    pushl %ebp
    movl %esp, %ebp

    movl $0, %eax
    movl $0, %ebx

    gameloop:
        call genprint

        pushl usleep_time
        call usleep
        addl $8, %esp

        call apply_rules
    jmp gameloop

    movl %ebp, %esp
    popl %ebp
ret

.type clrscr, @function
clrscr: /* clrscr() */
    pushl %ebp
    movl %esp, %ebp

    pushl $clrscr_fmt
    call printf
    addl $4, %esp

    movl $1, %eax
    movl $2, %ebx

    call gotoxy

    movl %ebp, %esp
    popl %ebp
ret

.type gotoxy, @function
gotoxy: /* gotoxy(EAX, EBX) */
    pushl %ebp
    movl %esp, %ebp

    pushl %eax
    pushl %ebx
    pushl $gotoxy_fmt
    call printf
    addl $12, %esp

    movl %ebp, %esp
    popl %ebp
ret

.type genprint, @function
genprint: /* genprint() */
    /*
     * INFO(Rafael): Well, it prints one generation.
     *
     * During its execution...
     *
     * EAX and EBX store the x, y coordinates used on gotoxy() calls
     * ECX holds the base offset of "cells" (a.k.a row index -> cells[][y]...)
     * EDI holds the col index of "cells" cells[x][]...
     * EDX holds the current byte stored in cell[x][y]...
     *
     */
    pushl %ebp
    movl %esp, %ebp

    pushl %ecx
    pushl %esi

    movl $0, %ecx
    movl $2, %ebx

    movl cell_col_max, %esi
    inc %esi

    rloop:
        movl $0, %edi
        movl $1, %eax

        cloop:
            pushl %eax

            movl cell_row_max, %eax
            inc %eax
            imul %ecx, %eax
            movl cells(%eax, %edi, 1), %edx

            popl %eax

            pushl %eax
            pushl %ebx
            pushl %ecx
            pushl %edx
            pushl %edi

            cmp $1, %dl
            je push_alive

            pushl $dead_fmt
            jmp cellprint

            push_alive:
                pushl $alive_fmt

            cellprint:
                call gotoxy

            call printf
            addl $4, %esp

            popl %edi
            popl %edx
            popl %ecx
            popl %ebx
            popl %eax

            inc %edi
            inc %eax
            cmp %esi, %edi
        jne cloop

        pushl %eax
        pushl %ebx
        pushl %ecx
        pushl %edx
        pushl %edi

        pushl $newline_fmt
        call printf
        addl $4, %esp

        popl %edi
        popl %edx
        popl %ecx
        popl %ebx
        popl %eax

        inc %ecx
        inc %ebx

        pushl %eax
        movl cell_row_max, %eax
        inc %eax
        cmp %eax, %ecx
        popl %eax
    jne rloop

    popl %esi
    popl %ecx

    movl %ebp, %esp
    popl %ebp
ret

.type apply_rules, @function
apply_rules: /* applyrules(EAX, EBX) */
    /*
     * INFO(Rafael): If life sucks to you, I think that you should start from here ;)
     */
    pushl %ebp
    movl %esp, %ebp
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    pushl %esi
    pushl %edi

    /* INFO(Rafael): Traversing the cells inspecting the neighbours of each one and then apply the game rules */

    movl $0, %eax

    movl cell_row_max, %ecx
    inc %ecx
    movl cell_col_max, %esi
    inc %esi

    applyrules_rloop:

        movl $0, %ebx

        applyrules_cloop:

            call inspect_neighbourhood

            pushl %eax
            movl %ebx, %edi
            imul %ecx, %eax

            pushl %ecx
            movl cells(%eax, %edi, 1), %ecx

            movl alive_cell_nr, %edx

            cmp $1, %cl
            jne deadcell_rules

            livecell_rules:

                cmp $2, %edx

                jl underpopulation

                je next_generation

                cmp $3, %edx

                je next_generation

                jg overpopulation

                /* RULE(1): Any live cell with fewer than two live neighbours dies, as if caused by underpopulation */
                underpopulation:
                    movb $0x00, cells(%eax, %edi, 1)
                    jmp applyrules_cloop_inc

                /* RULE(2): Any live cell with two or three live neighbours lives on to the next generation */
                next_generation:
                    jmp applyrules_cloop_inc

                /* RULE(3): Any live cell with more than three live neighbours dies, as if by overpopulation */
                overpopulation:
                    movb $0x00, cells(%eax, %edi, 1)
                    jmp applyrules_cloop_inc

            deadcell_rules:
                cmp $3, %edx
                jne applyrules_cloop_inc

                /* RULE(4): Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction */
                reproduction:
                    movb $0x01, cells(%eax, %edi, 1)

            applyrules_cloop_inc:
                inc %ebx

            popl %ecx
            popl %eax

            cmp %esi, %ebx
        jne applyrules_cloop

        inc %eax
        cmp %ecx, %eax
    jne applyrules_rloop


    popl %edi
    popl %esi
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax
    movl %ebp, %esp
    popl %ebp
ret

.type inspect_neighbourhood, @function
inspect_neighbourhood: /* inspect_neighbourhood(EAX, EBX) */
    /*
     * INFO(Rafael): Given a "high level" coordinate [ E.g.: cells(1;1) ]...
     *
     * ...this function will inspect the neighbours of the related cell, getting the amount of
     * dead and alive cells. When calling this function, the EAX register must hold the
     * "y" and the EBX the "x".
     *                                           T T T
     * This game defines your neighbourhood as:  T U T
     *                                           T T T
     */

    pushl %ebp
    movl %esp, %ebp
    pushl %eax
    pushl %ebx
    pushl %edx

    movl %ebx, %edi

    movl cell_row_max, %edx
    inc %edx

    movl $0, alive_cell_nr

    /* INFO(Rafael): Inspecting the state of cells[r+1][c] */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1c_end

    inc %eax

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r1c_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c] */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1c_end

    dec %eax

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r_1c_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c+1] */

    pushl %eax
    pushl %edi

    cmp cell_col_max, %edi
    je rule_r_c1_end

    inc %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c-1] */

    pushl %eax
    pushl %edi

    cmp cell_col_min, %edi
    je rule_r_c_1_end

    dec %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c-1] */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1_c_1_end

    cmp cell_col_min, %edi
    je rule_r_1_c_1_end

    dec %eax
    dec %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r_1_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c+1] */

    pushl %eax
    pushl %edi

    cmp cell_row_min, %eax
    je rule_r_1_c1_end

    cmp cell_col_max, %edi
    je rule_r_1_c1_end

    dec %eax
    inc %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r_1_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r_1_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c-1] */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1_c_1_end

    cmp cell_col_min, %edi
    je rule_r1_c_1_end

    inc %eax
    dec %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r1_c_1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c+1] */

    pushl %eax
    pushl %edi

    cmp cell_row_max, %eax
    je rule_r1_c1_end

    cmp cell_col_max, %edi
    je rule_r1_c1_end

    inc %eax
    inc %edi

    imul %edx, %eax
    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne rule_r1_c1_end

    movl alive_cell_nr, %eax
    inc %eax
    movl %eax, alive_cell_nr

    rule_r1_c1_end:
        popl %edi
        popl %eax

    popl %edx
    popl %ebx
    popl %eax
    movl %ebp, %esp
    popl %ebp
ret
