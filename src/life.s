/*
 *                                Copyright (C) 2017 by Rafael Santiago
 *
 * This is a free software. You can redistribute it and/or modify under
 * the terms of the GNU General Public License version 2.
 *
 */
.section .data
cells:
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    .byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

alive_fmt:
    .asciz "\033[41m \033[m\r"

dead_fmt:
    .asciz "\033[40m \033[m\r"

gotoxy_fmt:
    .asciz "\033[%d;%dH"

clrscr_fmt:
    .asciz "\033[2J"

newline_fmt:
    .asciz "\n"

test:
    .asciz "Result: %d\n"

dead_cell_nr:
    .int 0

alive_cell_nr:
    .int 0

.section .text

.globl _start

_start:

    call clrscr

    call life

    pushl $0
    call exit

.type life, @function
life:
    pushl %ebp
    movl %esp, %ebp

    call genprint

    movl $0, %eax
    movl $0, %ebx
    call applyrules

    movl %ebp, %esp
    popl %ebp
ret

.type clrscr, @function
clrscr: /* clrscr() */
    pushl %ebp
    movl %esp, %ebp

    pushl $clrscr_fmt
    call printf
    addl $4, %esp

    movl $1, %eax
    movl $2, %ebx

    call gotoxy

    movl %ebp, %esp
    popl %ebp
ret

.type gotoxy, @function
gotoxy: /* gotoxy(EAX, EBX) */
    pushl %ebp
    movl %esp, %ebp

    pushl %eax
    pushl %ebx
    pushl $gotoxy_fmt
    call printf
    addl $12, %esp

    movl %ebp, %esp
    popl %ebp
ret

.type genprint, @function
genprint: /* genprint() */
    /*
     * INFO(Rafael): Well, it prints one generation.
     *
     * During its execution...
     *
     * EAX and EBX store the x, y coordinates used on gotoxy() calls
     * ECX holds the base offset of "cells" (a.k.a row index -> cells[][y]...)
     * EDI holds the col index of "cells" cells[x][]...
     * EDX holds the current byte stored in cell[x][y]...
     *
     */
    pushl %ebp
    movl %esp, %ebp

    movl $0, %ecx
    movl $2, %ebx

    rloop:
        movl $0, %edi
        movl $1, %eax

        cloop:
            movl cells(%ecx, %edi, 1), %edx

            pushl %eax
            pushl %ebx
            pushl %ecx
            pushl %edx
            pushl %edi

            cmp $1, %dl
            je push_alive

            pushl $dead_fmt
            jmp cellprint

            push_alive:
                pushl $alive_fmt

            cellprint:
                call gotoxy

            call printf
            addl $4, %esp

            popl %edi
            popl %edx
            popl %ecx
            popl %ebx
            popl %eax

            inc %edi
            inc %eax
            cmp $20, %edi
        jne cloop

        pushl %eax
        pushl %ebx
        pushl %ecx
        pushl %edx
        pushl %edi

        pushl $newline_fmt
        call printf
        addl $4, %esp

        popl %edi
        popl %edx
        popl %ecx
        popl %ebx
        popl %eax

        addl $20, %ecx
        inc %ebx
        cmp $400, %ecx
    jne rloop

    movl %ebp, %esp
    popl %ebp
ret

.type applyrules, @function
applyrules: /* applyrules(EAX, EBX) */
    /*
     * INFO(Rafael): If life sucks to you, I think that you should start from here ;)
     */
    pushl %ebp
    movl %esp, %ebp
    pushl %eax
    pushl %ebx
    pushl %edi

    /* TODO(Rafael): Traverse the cells inspecting the neighbors of each one and then apply the game rules */

    imul $20, %eax
    movl %ebx, %edi

    call inspectneighborhood

    movl cells(%eax, %edi, 1), %ebx
    cmp $1, %bl
    jne deadcell_rules

    alivecell_rules:

    deadcell_rules:


    popl %edi
    popl %ebx
    popl %eax
    movl %ebp, %esp
    popl %ebp
ret

.type inspectneighborhood, @function
inspectneighborhood: /* inspectneighborhood(EAX, EBX) */
    /*
     * INFO(Rafael): Given a "high level" coordinate [ E.g.: cells(1;1) ]...
     *
     * ...this function will inspect the neighbors of the related cell, getting the amount of
     * dead and alive cells. When calling this function, the EAX register must hold the
     * "y" and the EBX the "x".
     *                                          T T T
     * This game defines your neighborhood as:  T U T
     *                                          T T T
     */

    pushl %ebp
    movl %esp, %ebp
    pushl %eax
    pushl %ebx
    pushl %edx

    imul $20, %eax
    movl %ebx, %edi

    movl $20, %ebx
    movl $0, %edx
    movl %edx, alive_cell_nr
    movl %edx, dead_cell_nr

    /* INFO(Rafael): Inspecting the state of cells[r+1][c] */

    pushl %eax
    pushl %edi

    inc %eax
    idiv %ebx

    movl cells(%edx, %edi, 1), %eax
    cmp $1, %al
    jne inc_dead_cell_nr.0

    inc_alive_cell_nr.0:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r1c_end

    inc_dead_cell_nr.0:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c] */

    pushl %eax
    pushl %edi

    cmp $0, %eax
    jne non_zero.1

    movl $19, %eax
    jmp inspect_cell.1

    non_zero.1:
        dec %eax

    inspect_cell.1:
        movl cells(%edx, %edi, 1), %eax
        cmp $1, %al
        jne inc_dead_cell_nr.1

    inc_alive_cell_nr.1:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r_1c_end

    inc_dead_cell_nr.1:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r_1c_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c+1] */

    pushl %eax
    pushl %edi

    pushl %eax

    movl %edi, %eax
    movl $0, %edx

    inc %eax
    idiv %ebx
    movl %edx, %edi

    popl %eax

    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne inc_dead_cell_nr.2

    inc_alive_cell_nr.2:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r_c1_end

    inc_dead_cell_nr.2:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r][c-1] */

    pushl %eax
    pushl %edi

    cmp $0, %edi
    jne non_zero.3

    movl $19, %edi
    jmp inspect_cell.3

    non_zero.3:
        dec %esi

    inspect_cell.3:
        movl cells(%eax, %edi, 1), %eax
        cmp $1, %al
        jne inc_dead_cell_nr.3

    inc_alive_cell_nr.3:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r_c_1_end

    inc_dead_cell_nr.3:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c-1] */

    pushl %eax
    pushl %edi

    cmp $0, %eax
    jne non_zero.4.0
    movl $19, %eax
    jmp dec_edi.4

    non_zero.4.0:
        dec %eax

    dec_edi.4:
        cmp $0, %edi
        jne non_zero.4.1
        movl $19, %edi
        jmp inspect_cell.4

    non_zero.4.1:
        dec %edi

    inspect_cell.4:
        movl cells(%eax, %edi, 1), %eax
        cmp $1, %al
        jne inc_dead_cell_nr.4

    inc_alive_cell_nr.4:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r_1_c_1_end

    inc_dead_cell_nr.4:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r_1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r-1][c+1] */

    pushl %eax
    pushl %edi

    cmp $0, %eax
    jne non_zero.5
    movl $19, %eax
    jmp inc_edi.5

    non_zero.5:
        dec %eax

    inc_edi.5:
        pushl %eax

        movl %edi, %eax
        movl $0, %edx

        inc %eax
        idiv %ebx
        movl %edx, %edi

        popl %eax

    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne inc_dead_cell_nr.5

    inc_alive_cell_nr.5:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r_1_c1_end

    inc_dead_cell_nr.5:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r_1_c1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c-1] */

    pushl %eax
    pushl %edi

    movl $0, %edx
    inc %eax
    idiv %ebx
    movl %edx, %eax

    cmp $0, %edi
    jne non_zero.6
    movl $19, %edi
    jmp inspect_cell.6

    non_zero.6:
        dec %edi

    inspect_cell.6:
        movl cells(%eax, %edi, 1), %eax
        cmp $1, %al
        jne inc_dead_cell_nr.6

    inc_alive_cell_nr.6:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r1_c_1_end

    inc_dead_cell_nr.6:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r1_c_1_end:
        popl %edi
        popl %eax

    /* INFO(Rafael): Inspecting the state of cells[r+1][c+1] */

    pushl %eax
    pushl %edi

    movl $0, %edx
    inc %eax
    idiv %ebx
    movl %edx, %eax

    pushl %eax

    movl %edi, %eax
    movl $0, %edx

    inc %eax
    idiv %ebx
    movl %edx, %edi

    popl %eax

    movl cells(%eax, %edi, 1), %eax
    cmp $1, %al
    jne inc_dead_cell_nr.7

    inc_alive_cell_nr.7:
        movl alive_cell_nr, %eax
        inc %eax
        movl %eax, alive_cell_nr
        jmp rule_r1_c1_end

    inc_dead_cell_nr.7:
        movl dead_cell_nr, %eax
        inc %eax
        movl %eax, dead_cell_nr

    rule_r1_c1_end:
        popl %edi
        popl %eax

    popl %edx
    popl %ebx
    popl %eax
    movl %ebp, %esp
    popl %ebp
ret
/*
#    movl $22, %eax
#    movl $0, %edx
#    movl $20, %ebx
#    divl %ebx

#    pushl %edx
#    pushl $test
#    call printf
#    addl $8, %esp

####
#
#    pushl %eax
#
#    movl $41, %eax
#    idiv %ebx
#
#    pushl %edx
#    pushl $test
#    call printf
#    addl $8, %esp
#
#    popl %eax
#
#    movl $0, %edx
#
####
*/
